# 문제 1
* [가장 먼 노드](https://programmers.co.kr/learn/courses/30/lessons/49189)

# 내용
* BFS를 활용해서 노드를 순회하는데 이때 최단거리를 찾기 위해 노드 간 거리가 제일 짧은 것으로만 Queue에 넣어주게 되면
  dist배열에는 출발지점 1에서의 최단 경로 거리값이 저장되고 이들 중 가장 큰 값을 찾으면 된다.

# 풀이
```java
package programmers.level3;
import java.util.*;

public class Programmers_가장먼노드 {
  
  static List<Integer>[] map;
  static int[] dist;
  static int max=0;
  public static int solution(int n, int[][] edge) {
    int answer = 0;
    map = new ArrayList[n+1];
    dist = new int[n+1];
    Arrays.fill(dist, Integer.MAX_VALUE);
    dist[0] = 0;
    dist[1] = 0;
    for(int i=0;i<=n;i++) map[i] = new ArrayList<>();

    //간선 연결 완료
    for(int i=0;i<edge.length;i++){
        int a = edge[i][0];
        int b = edge[i][1];
        map[a].add(b);
        map[b].add(a);
    }

    BFS(1);

    for(int i=1;i< dist.length;i++) if(max < dist[i]) max = dist[i];
    for(int i=1;i< dist.length;i++) if(max == dist[i]) answer++;

    System.out.println(answer);

    return answer;
  }

  public static void BFS(int start){

    Queue<Integer> queue = new LinkedList<>();
    queue.add(start);

    while(!queue.isEmpty()){
      int now = queue.poll();

      for(int i=0;i<map[now].size();i++){
        int linkNum = map[now].get(i);
        if(dist[linkNum] > dist[now] + 1){
          dist[linkNum] = dist[now] +1;
          queue.add(linkNum);
        }
      }
    }
  }

  public static void main(String[] args) {
    int n = 6;
    int[][] edges = {{3, 6}, {4, 3}, {3, 2}, {1, 3}, {1, 2}, {2, 4}, {5, 2}};
    solution(6, edges);
  }

}

```

<br>

# 문제 2
* [녹색 옷 입은 애가 젤다지?](https://www.acmicpc.net/problem/4485)

# 내용
* 다익스트라 알고리즘을 활용하여 edge의 값을 바탕으로 dist[][] 값이 작을 때에만 접근하여 
  우선순위큐로 최단거리를 구해주었다.

# 풀이
```java
package GOLD;
import java.util.*;

//녹색 옷을 입은 놈이 젤다지?
public class baek4485 {

  static int[][] map;
  static int[][] dist;
  static int[] dx = {0, 0, 1, -1};
  static int[] dy = {1, -1, 0, 0};
  static int n;
  
  static void Dijkstra(){
    PriorityQueue<Point> pq = new PriorityQueue<>();
    pq.add(new Point(0,0, map[0][0])); 

    while(!pq.isEmpty()){
      Point nowP = pq.poll();

      for(int i=0;i<4;i++){
        int nextX = nowP.x + dx[i];
        int nextY = nowP.y + dy[i];
        if(isValid(nextX, nextY)){
          if(dist[nextX][nextY] > dist[nowP.x][nowP.y] + map[nextX][nextY]){
            dist[nextX][nextY] = dist[nowP.x][nowP.y] + map[nextX][nextY];
            pq.add(new Point(nextX, nextY, dist[nextX][nextY]));
          }
        }
      }
    }
  }

  static boolean isValid(int x, int y){
    if(x < 0 || x >= n || y < 0 || y >= n){
      return false;
    }
    return true;
  }

  static class Point implements Comparable<Point>{
    int x; //행
    int y; //열
    int value;
    public Point(int x, int y, int value){
      this.x = x;
      this.y = y;
      this.value = value;
    }

    public int compareTo(Point p){
      if(this.value > p.value){
        return 1;
      }
      return -1;
    }
  }

  public static void main(String[] args) {

    Scanner sc = new Scanner(System.in);
    int index=0;
    while(true){
      n = sc.nextInt();
      if(n == 0) break;
      index++;
      map = new int[n][n];
      dist = new int[n][n];

      for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
          map[i][j] = sc.nextInt();
          dist[i][j] = Integer.MAX_VALUE;
        }
      }
      dist[0][0] = map[0][0];

      Dijkstra();

      System.out.println("Problem "+index+": "+dist[n-1][n-1]);

    }
  }
}


```