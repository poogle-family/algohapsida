# 문제
* [가장 먼 노드](https://programmers.co.kr/learn/courses/30/lessons/49189)

# 내용
* BFS를 활용해서 노드를 순회하는데 이때 최단거리를 찾기 위해 노드 간 거리가 제일 짧은 것으로만 Queue에 넣어주게 되면
  dist배열에는 출발지점 1에서의 최단 경로 거리값이 저장되고 이들 중 가장 큰 값을 찾으면 된다.

# 풀이
```java
package programmers.level3;
import java.util.*;

public class Programmers_가장먼노드 {
  
  static List<Integer>[] map;
  static int[] dist;
  static int max=0;
  public static int solution(int n, int[][] edge) {
    int answer = 0;
    map = new ArrayList[n+1];
    dist = new int[n+1];
    Arrays.fill(dist, Integer.MAX_VALUE);
    dist[0] = 0;
    dist[1] = 0;
    for(int i=0;i<=n;i++) map[i] = new ArrayList<>();

    //간선 연결 완료
    for(int i=0;i<edge.length;i++){
        int a = edge[i][0];
        int b = edge[i][1];
        map[a].add(b);
        map[b].add(a);
    }

    BFS(1);

    for(int i=1;i< dist.length;i++) if(max < dist[i]) max = dist[i];
    for(int i=1;i< dist.length;i++) if(max == dist[i]) answer++;

    System.out.println(answer);

    return answer;
  }

  public static void BFS(int start){

    Queue<Integer> queue = new LinkedList<>();
    queue.add(start);

    while(!queue.isEmpty()){
      int now = queue.poll();

      for(int i=0;i<map[now].size();i++){
        int linkNum = map[now].get(i);
        if(dist[linkNum] > dist[now] + 1){
          dist[linkNum] = dist[now] +1;
          queue.add(linkNum);
        }
      }
    }
  }

  public static void main(String[] args) {
    int n = 6;
    int[][] edges = {{3, 6}, {4, 3}, {3, 2}, {1, 3}, {1, 2}, {2, 4}, {5, 2}};
    solution(6, edges);
  }

}

```