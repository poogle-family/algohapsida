# 문제
* [백준 냅색문제 링크](https://www.acmicpc.net/problem/1450)

# 내용
* 물건을 넣거나, 넣지 않거나로 판단하여 dfs로 접근하였으나 2^30 의 복잡도로 인해서 시간초과가 났었습니다.
* 이를 해결하기 위해서 주어진 배열을 반으로 나누어 각각을 dfs로 구한 뒤, 둘을 더함으로써 문제를 해결하였습니다.
* 다만, 두 개의 배열을 더할 때, 이분 탐색을 통한 upperBound로, leftSide의 특정 값 + rightSide의 특정 값 <= c 가 되게끔 하였습니다.
* 과거의 풀었던 부분수열의 합2 와 같은 문제해결 형태를 취하고 있습니다.

# 풀이
```java
package boj_1450;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {

    static List<Integer> leftSide = new ArrayList<>();
    static List<Integer> rightSide = new ArrayList<>();
    static int n;
    static int c;
    static int[] things;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        c = sc.nextInt();
        things = new int[n];
        for (int i = 0; i < n; i++) {
            things[i] = sc.nextInt();
        }
        dfs(leftSide, 0, n / 2, 0);
        dfs(rightSide, n / 2, n, 0);
        Collections.sort(rightSide);
        int answer = 0;
        int count = 0;
        for (int i = 0; i < leftSide.size(); i++) {
            count = getUpperBoundIndex(rightSide, leftSide.get(i));
            answer += count + 1;
        }
        System.out.println(answer);
    }

    private static int getUpperBoundIndex(List<Integer> list, Integer value) {
        int start = 0;
        int end = list.size() - 1;
        while (start <= end) {
            int mid = (start + end) / 2;
            if (list.get(mid) <= c - value) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        return end;
    }

    private static void dfs(List<Integer> list, int start, int end, int sum) {
        if (sum > c) return;
        if (start == end) {
            list.add(sum);
            return;
        }
        dfs(list, start + 1, end, sum);
        dfs(list, start + 1, end, sum + things[start]);
    }

}



```
