# ë¬¸ì œ
* [ì‚¬ë¼ì§€ëŠ” ë°œíŒ](https://programmers.co.kr/learn/courses/30/lessons/92345)

# ë‚´ìš©
- í•©ê²©ë¥  0.78% ë¬¸ì œë‹µê²Œ ë„ˆë¬´ ì–´ë ¤ì› ë„¤ìš” ğŸ˜‚
- [ë°”í‚¹ë…ë‹˜ í’€ì´ ì˜ìƒ](https://www.youtube.com/watch?v=caGtdr3_nxs&t=1s), [ì¹´ì¹´ì˜¤ í•´ì„¤](https://tech.kakao.com/2022/01/14/2022-kakao-recruitment-round-1/), í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ì—ì„œ ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´ë¥¼ ì°¸ê³ í–ˆìŠµë‹ˆë‹¤.
- ì´í•´í•œ ë°”ë¥¼ ì£¼ì„ìœ¼ë¡œ ë‹¬ì•˜ìŠµë‹ˆë‹¤. í‹€ë¦° ë¶€ë¶„ì´ ìˆë‹¤ë©´ ì§€ì í•´ì£¼ì„¸ìš”!

```java
class Solution {
    int[] dx = {0, 0, -1, 1};
    int[] dy = {-1, 1, 0, 0};

    public int solution(int[][] board, int[] aloc, int[] bloc) {
        return recursive(board, aloc, bloc).move;
    }

    private Player recursive(int[][] board, int[] aloc, int[] bloc) {

        // ìì‹ ì˜ ë°œíŒì´ ì‚¬ë¼ì¡Œë‹¤ë©´ íŒ¨ë°°
        if (board[aloc[0]][aloc[1]] == 0) {
            return new Player(false, 0);
        }

        boolean canWin = false;

        // ìì‹ ì´ ì´ê²¼ì„ ë•Œ ìµœì†Œë¡œ ì›€ì§ì¼ ê±°ë¦¬
        int minMove = Integer.MAX_VALUE;

        // ìì‹ ì´ ì¡Œì„ ë•Œ ìµœëŒ€ë¡œ ì›€ì§ì¼ ê±°ë¦¬
        int maxMove = 0;

        for (int i = 0; i < 4; i++) {
            int drow = aloc[0] + dx[i];
            int dcol = aloc[1] + dy[i];

            // ë³´ë“œë¥¼ ë²—ì–´ë‚¬ê±°ë‚˜ ë°œíŒì´ ì—†ì„ ê²½ìš° ë‹¤ìŒ ë°œíŒ ê²€ìƒ‰
            if (outOfBounds(board, drow, dcol) || board[drow][dcol] == 0) {
                continue;
            }

            board[aloc[0]][aloc[1]] = 0;
            final Player opponent = recursive(board, bloc, new int[]{drow, dcol});
            board[aloc[0]][aloc[1]] = 1;

            // ìƒëŒ€ë°©ì´ ì´ê²¼ì„ ê²½ìš°
            if (opponent.canWin) {

                // ë‚´ê°€ ì¡Œìœ¼ë¯€ë¡œ ìµœëŒ€ë¡œ ì›€ì§ì—¬ì•¼ í•˜ëŠ” ê±°ë¦¬ë¥¼ ì €ì¥í•œë‹¤.
                // ë‚˜ë„, ìƒëŒ€ë°©ë„ ìµœì ì˜ ê²½ìš°ë¡œ ì›€ì§ì¸ë‹¤.
                // ë‚´ê°€ ìµœëŒ€ë¡œ ë„ë§ì³¤ì„ ë•Œê°€ ìƒëŒ€ë°©ì´ ìµœì†Œ ê±°ë¦¬ë¡œ ì¢‡ì•„ì™”ì„ ê²½ìš°ì´ë‹¤.
                // ë‚´ê°€ í•œ ì¹¸ ì›€ì§ì˜€ìœ¼ë¯€ë¡œ ë‚˜ì˜ ìµœëŒ€ ê±°ë¦¬ì— `ìƒëŒ€ë°©ì˜ ìµœì†Œ ê±°ë¦¬ + 1`ì„ ì €ì¥í•œë‹¤
                maxMove = Math.max(maxMove, opponent.move + 1);

                // ìƒëŒ€ë°©ì´ ì¡Œì„ ê²½ìš°
            } else {
                canWin = true;

                // ë‚´ê°€ ì´ê²¼ìœ¼ë¯€ë¡œ ìµœì†Œë¡œ ì›€ì§ì—¬ì•¼ í•˜ëŠ” ê±°ë¦¬ë¥¼ ì €ì¥í•œë‹¤.
                minMove = Math.min(minMove, opponent.move + 1);
            }
        }

        // ë‚´ê°€ ì´ê¸°ëŠ” ê²½ìš°ê°€ ìˆì„ ê²½ìš° í•´ë‹¹ ë°œíŒìœ¼ë¡œ ì´ë™í•œë‹¤
        int move = canWin ? minMove : maxMove;
        return new Player(canWin, move);
    }

    public boolean outOfBounds(int[][] board, int row, int col) {
        return row < 0 || row >= board.length || col < 0 || col >= board[0].length;
    }

    private static class Player {
        boolean canWin;
        int move;

        public Player(boolean canWin, int move) {
            this.canWin = canWin;
            this.move = move;
        }
    }
}
```
