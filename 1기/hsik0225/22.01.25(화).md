# 문제
* [최단경로](https://www.acmicpc.net/problem/1753)

# 내용
- 가중치가 양수이므로 다익스트라로 풀이
- 나무위키 피셜 다익스트라 시간복잡도는 `O((V+E)logV)`
  - 블로그마다 시간복잡도 이야기가 달라서 어떤게 맞는건지 잘 모르겠다. 개인 블로그보다는 공신력있는 나무위키를 믿어보기로..
  - 각 노드마다 미방문 노드 중 출발점으로부터 현재까지 계산된 최단 거리를 가지는 노드를 찾는데 `O(VlogV)`의 시간이 필요하다. 
    - 모든 노드 O(V)에 대해 힙에서 최소값을 추출O(logV))해야한다.
  - 각 노드마다 이웃한 노드의 최단 거리를 갱신할 때 `O(ElogV)`의 시간이 필요
    - 각 노드마다 모든 이웃을 확인하는 것은 모든 edge를 확인하는 것과 같고 O(E), 매번 힙에서 최단 거리를 갱신O(logV)해야 하기 때문이다

- 몇 주간 다익스트라를 안 했더니 Comparable을 구현 안 하거나 Queue를 우선순위 큐가 아닌 링크드리스트로 생성하는 등 여러 실수가 있었다. 구현 방법을 잊지 않게 자주 풀이해야겠다.

```java
public class Main {

    public static final int INF = (int) 1e9;
    public static final List<List<Node>> GRAPH = new ArrayList<>();

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw= new BufferedWriter(new OutputStreamWriter(System.out));

        final String[] setting = br.readLine().split(" ");
        int v = Integer.parseInt(setting[0]);
        int e = Integer.parseInt(setting[1]);
        int start = Integer.parseInt(br.readLine());

        for (int i = 0; i <= v; i++) {
            GRAPH.add(new ArrayList<>());
        }

        for (int i = 0; i < e; i++) {
            final String[] edge = br.readLine().split(" ");
            GRAPH.get(Integer.parseInt(edge[0])).add(new Node(edge[1], edge[2]));
        }

        boolean[] visited = new boolean[v + 1];
        int[] distances = new int[v + 1];
        Arrays.fill(distances, INF);
        distances[start] = 0;

        Queue<Node> queue = new PriorityQueue<>();
        queue.add(new Node(start, 0));
        while (!queue.isEmpty()) {
            final Node node = queue.poll();

            if (visited[node.value]) {
                continue;
            }

            visited[node.value] = true;
            for (Node nextNode : GRAPH.get(node.value)) {
                if (distances[nextNode.value] > distances[node.value] + nextNode.distance) {
                    distances[nextNode.value] = distances[node.value] + nextNode.distance;
                    queue.add(new Node(nextNode.value, distances[nextNode.value]));
                }
            }
        }

        for (int i = 1; i < distances.length; i++) {
            String distance = distances[i] == INF ? "INF" : Integer.toString(distances[i]);
            bw.write(distance + "\n");
        }

        bw.flush();
    }

    private static class Node implements Comparable<Node> {
        int value;
        int distance;

        public Node(String value, String distance) {
            this(Integer.parseInt(value), Integer.parseInt(distance));
        }

        public Node(int value, int distance) {
            this.value = value;
            this.distance = distance;
        }

        @Override
        public int compareTo(Node o) {
            return distance - o.distance;
        }
    }
}
```
