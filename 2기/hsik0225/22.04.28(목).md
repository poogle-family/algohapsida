# 문제
* [걷기](https://www.acmicpc.net/problem/1459)

## 풀이
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        long X = scanner.nextLong();
        long Y = scanner.nextLong();
        long W = scanner.nextLong();
        long S = scanner.nextLong();

        if (2 * W <= S) {
            System.out.println((X + Y) * W);
            return;
        }

        long diagonal = Math.min(X, Y) * S;
        long restStraight = Math.abs(X - Y) * W;
        long restDiagonal = Math.abs(X - Y) * S;
        if ((X + Y) % 2 == 1) {
            restDiagonal -= S;
            restDiagonal += W;
        }

        System.out.println(diagonal + Math.min(restStraight, restDiagonal));
    }
}
```

# 문제
* [무지의 먹방 라이브](https://programmers.co.kr/learn/courses/30/lessons/42891)

## 내용
- 시간복잡도: `O(logN)`
  - `food_times`를 우선순위 큐에 추가하는데 `O(logN)`
  - `while문`은 foods의 사이즈만큼 동작하므로 `O(N)` 
  
## 풀이
```java
import java.util.*;

class Solution {
    public int solution(int[] food_times, long k) {
        PriorityQueue<Integer> foods = new PriorityQueue<>();
        for (int food_time : food_times) {
            foods.add(food_time);
        }

        int minus = 0;
        while (!foods.isEmpty()) {
            while (!foods.isEmpty() && foods.peek() - minus == 0) {
                foods.poll();
            }

            if (foods.size() > k) {
                break;
            }

            k -= foods.size();

            minus++;
        }

        for (int i = 0; i < food_times.length; i++) {
            if (food_times[i] > minus) {
                if (k == 0) {
                    return i + 1;
                }
                k--;
            }
        }

        return -1;
    }
}
```
