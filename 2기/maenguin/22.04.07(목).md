# 문제
* [나무 자르기](https://www.acmicpc.net/problem/2805)

# 내용
* 문제의 크기를 보고 이분 탐색을 사용하면 좋을것 같아서 이분 탐색을 사용했습니다.(하한탐색 + 구하는 값이 내림차순)
* 나중에 이분탐색 코드 또 쓸려고 index를 사용해 value를 구하는 부분은 함수로 빼버렸습니다.

# 풀이
```java
import java.util.Scanner;
import java.util.function.IntToLongFunction;

public class P2805_나무자르기 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int M = sc.nextInt();
        int[] treeHeights = new int[N];
        for (int i = 0; i < treeHeights.length; i++) {
            treeHeights[i] = sc.nextInt();
        }
        System.out.println(lowerBoundBinarySearchWithAsc(
            cutterHeight -> getTreeMeterToTake(treeHeights, cutterHeight),
            0,
            Integer.MAX_VALUE,
            M
        ));
    }

    private static int lowerBoundBinarySearchWithAsc(IntToLongFunction function, int start, int end, int target) {
        int left = start;
        int right = end;
        while (left <= right) {
            int mid = left + (right - left)/2;
            if (function.applyAsLong(mid) >= target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return right;
    }

    private static long getTreeMeterToTake(int[] treeHeights, int cutterHeight) {
        long result = 0;
        for (int treeHeight : treeHeights) {
            if (treeHeight > cutterHeight) {
                result += treeHeight - cutterHeight;
            }
        }
        return result;
    }

}
```


<br>
<br>

# 문제
* [가사 검색](https://programmers.co.kr/learn/courses/30/lessons/60060)

# 내용
* 뭔가 쿼리가 주어지는 문제는 주어진 데이터를 쿼리로 추출하기 쉽게 미리 가공해두면 좋기 때문에 세그먼트 트리 처럼 가공했습니다.
```java
        root
         f
         r
    o        a
 d n s z     m
 o t t e     e
       n

문제 샘플로 보면 위와 같이 만들어주는데
각 노드마다 word 길이에 해당하는 개수를 지니도록 합니다.
예를 들면 o 노드는 길이가 5인 word가 3개(frodo, front, frost) 있고 길이가 6인 word가 1개(frozen) 있습니다.
이때 쿼리가 fro?? 이면 word길이가 5이므로 3개를 반환합니다.
```
* ?로 시작하는 경우와 ?로 끝나는 두 가지 경우가 있기 때문에 두 가지 세그먼트 트리를 만들었습니다.
* 코드가 겹치는 부분이 많은데 그 차이가 for문을 역으로 탐색하냐 아니냐뿐 입니다. 이거 코드 중복 어떻게 줄이면 좋을까요??

# 풀이
```java
import java.util.HashMap;
import java.util.Map;

public class 가사검색 {

    public int[] solution(String[] words, String[] queries) {
        Node root = new Node();
        for (String word : words) {
            Node curNode = root;
            curNode.addLengthCount(word.length());
            for (int i = 0; i < word.length(); i++) {
                curNode = curNode.addChild(word.charAt(i));
                curNode.addLengthCount(word.length());
            }
        }

        Node reversedRoot = new Node();
        for (String word : words) {
            Node curNode = reversedRoot;
            curNode.addLengthCount(word.length());
            for (int i = word.length() - 1; i >= 0; i--) {
                curNode = curNode.addChild(word.charAt(i));
                curNode.addLengthCount(word.length());
            }
        }

        int[] answer = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            String query = queries[i];
            answer[i] = query.charAt(0) != '?' ? getQueryResult(root, query) : getQueryResultReverse(reversedRoot, query);
        }
        return answer;
    }

    private int getQueryResult(Node root, String query) {
        int result = 0;
        Node curNode = root;
        for (int j = 0; j < query.length(); j++) {
            char c = query.charAt(j);
            if (c == '?') {
                result = curNode.lengthAndCountPairs.getOrDefault(query.length(), 0);
                break;
            }
            if (!curNode.children.containsKey(c)) break;
            curNode = curNode.children.get(c);
        }
        return result;
    }

    private int getQueryResultReverse(Node root, String query) {
        int result = 0;
        Node curNode = root;
        for (int j = query.length() - 1; j >= 0; j--) {
            char c = query.charAt(j);
            if (c == '?') {
                result = curNode.lengthAndCountPairs.getOrDefault(query.length(), 0);
                break;
            }
            if (!curNode.children.containsKey(c)) break;
            curNode = curNode.children.get(c);
        }
        return result;
    }

    static class Node {
        Map<Character, Node> children;
        Map<Integer, Integer> lengthAndCountPairs;

        public Node() {
            this.children = new HashMap<>();
            this.lengthAndCountPairs = new HashMap<>();
        }

        private Node addChild(char c) {
            return children.computeIfAbsent(c, character -> new Node());
        }

        private void addLengthCount(Integer leftLength) {
            lengthAndCountPairs.put(leftLength, lengthAndCountPairs.getOrDefault(leftLength, 0) + 1);
        }
    }

}
```
